"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var invariant = _interopRequire(require("invariant"));

var getControllableValue = function (name, state, props) {
  return props[name] === undefined ? state[name] : props[name];
};
var capFirst = function (str) {
  return "" + str.slice(0, 1).toUpperCase() + "" + str.slice(1);
};
var callbackName = function (prop) {
  return "on" + capFirst(prop) + "Change";
};

module.exports = {

  getInitialState: function getInitialState() {
    invariant(!!this.controllables, "Components that use ControllablesMixin must define a controllables array");
    var state = {};
    for (var i = 0; i < this.controllables.length; i++) {
      var _name = this.controllables[i];
      var defaultValue = this.props["default" + capFirst(_name)];
      if (defaultValue != null) state[_name] = defaultValue;
    }
    return state;
  },

  getControllableValue: (function (_getControllableValue) {
    var _getControllableValueWrapper = function getControllableValue(_x) {
      return _getControllableValue.apply(this, arguments);
    };

    _getControllableValueWrapper.toString = function () {
      return _getControllableValue.toString();
    };

    return _getControllableValueWrapper;
  })(function (name) {
    return getControllableValue(name, this.state, this.props);
  }),

  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    for (var i = 0; i < this.controllables.length; i++) {
      var _name = this.controllables[i];
      var newValue = this.state[_name];
      if (newValue === prevState[_name]) continue;
      var oldValue = getControllableValue(_name, prevState, prevProps);
      var cb = this.props[callbackName(_name)];
      if (cb) cb(newValue, oldValue);
    }
  } };